<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        class TreeNode{
            constructor(data){
                this.data = data;
                this.children = [];

            }
            insert(data, index){
                if(index === undefined){

                    // 데이터를 넣으면 자식 배열에 노드를 추가해 데이터를 넣고 children을 추가함
                    this.children.push(new TreeNode(data));
                }else if(index > -1){
                    this.children[index].push(new TreeNode(data));
                }

            }
            insertNode(node){
                this.children.push(node);
            }
        }

        const testTree = new TreeNode(1);
        testTree.insert(2);
        testTree.insert(3);
        testTree.insertNode(new TreeNode(5));
        console.log(testTree);
        console.log(typeof testTree); //object

        const testTree2 = new TreeNode(6);
        testTree2.insertNode(testTree);
        console.log(testTree2);


        // 이진 트리
        class BinaryNode{
            constructor(data){
                this.data = data;
                // 2진 트리이기 때문에 왼쪽 오른쪽
                this.left = null;
                this.right = null;
            }
        }

        // 이진 검색 트리 : 검색을 하기 위한 이진트리(보통 숫자를 많이 쓴다.)
        // 만약 맨위 4인데 4가 들어오면 안넣고, 해당노드를 기준으로 작은거 왼쪽(2)
        // 큰 거 오른쪽(7)에 넣는 것이 서치트리이다.(이진 검색 트리)
        // 단점 : 1~10까지 넣으면 그냥 대각선으로 나온다. 대신 검색하기 편하다고 한다.(랜덤할 때 사용)
        class BinarySearchTree{
            constructor(){
                this.root = null;
            }
            insert(data){
                // 이진 검색 트리에 루트가 없으면
                if(!this.root){
                    // 루트에 새로 위의 이진 트리를 만들어서 그 안에 데이터를 정의해줌
                    this.root = new BinaryNode(data);
                    return;
                }
                let node = this.root;
                while(true){
                    // 새로 들어온 데이터가 기존 노드의 데이터보다 작으면(왼쪽에 넣어야 함)
                    if(node.data > data){
                        // 노드의 왼쪽이 이미 있으면
                        if(node.left){
                            // 다음 노드 왼쪽에 넣기 위해
                            // 현재 노드를 현재 노드의 왼쪽 노드로 바꿔준다.
                            node = node.left;
                        }else{
                            // 노드의 왼쪽이 비어 있으면
                            // 노드를 새로 만들어 거기에 데이터도 함께 넣어주고 리턴한다.
                            node.left = new BinaryNode(data);
                            return;
                        }
                    // 새로 들어온 데이터가 기존 노드의 데이터보다 크면(오른쪽에 넣어야 함)
                    }else if(node.data < data){
                        // 만약 노드의 오른쪽이 이미 존재하면
                        if(node.right){
                            // 노드의 오른쪽에 들어가기 위해 기존 노드를 기존 노드의 오른쪽 노드로 바꿔준다.
                            node = node.right;
                        // 
                        }else{
                            // 없으면 새로 만들어줌
                            node.right = new BinaryNode(data);
                            return;
                        }
                    }else return;
                }// while문 end
            }//insert() end

            // 이진트리 삭제 메서드(생각해보자)
            remove(data, node = this.root){
                // data : 삭제할 놈
                // node : 맨 위에 놈을 node에 정의해 줌

                // 자식이 없는 놈을 삭제
                // 자식이 하나인 놈을 삭제 - 그래도 연결은 여러개일수 있음
                // 자식이 둘인 놈을 삭제
                    // 1. 오른쪽자식 중에서 가장 작은 값을 15자리로 옮긴다
                    // 2. 왼쪽 자식 중에서 가장 큰 값을 15자리로 옮긴다.
                    // 그 놈을 찾는 방법이 궁금 if while?

                console.log(data);
                console.log(node);
            };
            // 위의 코드를 풀어서 쓴 내용이다.
            // remove(data, node){
            //     if(!node){
            //         node = this.root;
            //     }
            // };
        }//BinarySearchTree class end - 이진 검색 트리

        let testBinarySearchTree = new BinarySearchTree();
        testBinarySearchTree.insert(227);
        testBinarySearchTree.insert(777);
        testBinarySearchTree.insert(727);
        testBinarySearchTree.insert(141);
        testBinarySearchTree.insert(1229);
        testBinarySearchTree.insert(18);
        testBinarySearchTree.insert(666);
        testBinarySearchTree.insert(780);
        console.log(testBinarySearchTree);

        
        // testBinarySearchTree.remove(1);
        testBinarySearchTree.remove();



    </script>
</body>
</html>