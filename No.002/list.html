<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 22.08.17 -->
    <!-- 
      ol과 ul은 리스트를 작성한다. 
      리스트의 부모 태그
      li는 자식 태그
    -->
    <ol type="1" start="4">
      <!-- 숫자가 있어, ordered list -->
      <li>첫번째</li>
      <!-- list -->
      <li>두번째</li>
      <li>두번째</li>
      <li>두번째</li>
      <li>두번째</li>
      <li>두번째</li>
    </ol>
    <ul type="dics">
      <!-- 숫자가 없어, unordered list -->
      <li>첫번째</li>
      <li>두번째</li>
    </ul>
  </body>

  <script>
    function solution(board, moves) {
    //[[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]
    // 네오:1, 무지:2, 콘:3, 어피치:4, 프로도:5
    
    // 인형을 뽑으면 담을 바구니
    let basket = [];
    // 바구니에 같은 것이 들어갔을 때 2씩 증가함
    let popCount = 0;
    
    // 보드 배열 안의 배열을 빼낼수 있는 배열 숫자 항목으로 변환해줌(배열 안의 배열 안의 배열)
    for(let i = 0; i<board.length; i++){
        board[i] = board[i].map((a) => Number(a));
    }
    // 사용자의 게임 시도 내역을 숫자로 변환해줌
    // moves = moves.toString().split(",");
    moves = moves.map((a) => Number(a-1));
    
    // 일단 사용자의 행동 전부 실행해야 하며 무시하고 하나의 실행에 대해서 작성한다. moves[0]

    

    //0~7
    for(let i = 0; i<moves.length; i++){
        
        // 보드 총 길이가 5이면 배열의 4번째인 마지막 것을 차례로 가져옴
        // 보드 총 길이가 5이면 맨위 0부터 4번째까지 해당되고 
        // 그 보드 0번째의 moves[0]부터 차례로 가져와야 한다.01234
        for(let j = 0; j<board.length; j++){
          
          //〉	[[0, 0, 0, 0, 0], [0, 0, 1, 0, 3], [0, 2, 5, 0, 1], [4, 2, 4, 4, 2], [3, 5, 1, 3, 1]], [1, 5, 3, 5, 1, 2, 1, 4]
          // console.log(`board[${j}][moves[${i}]]=${board[j][moves[i]]}`);
            // return moves;
            // return board;
            
            // moves의 0번째 값이
            // board 배열을 5번 돌면서 board[5][0], board[4][0]을 차례로 돌면서
            // 값이 0이 아니면 그 값을 리턴해주고 만약 0이면 그냥 return해준다.
            if(board[j][moves[i]]){
                basket.push(board[j][moves[i]]);
                board[j][moves[i]]=0;
                console.log(board);
                break;
            }
            console.log(basket);
        }
        // return board[4][moves[0]];
        
        // return basket;
        
    }
    // return board[2].toString().split(",");
    
        // 바구니 i와 i+1에 같은것이 들어오면 삭제삭제해주고 카운트를 2증가 시킨다.
    
    return basket;
    
    
    for(let i = 0; i<basket.length; i++){
        if(basket[i]==basket[i+1]){
            popCount++;
        }
    }
    
    
    // 최종 카운트를 출력해준다.
    return popCount;
    
}
solution(	[[0, 0, 0, 0, 0], [0, 0, 1, 0, 3], [0, 2, 5, 0, 1], [4, 2, 4, 4, 2], [3, 5, 1, 3, 1]], [1, 5, 3, 5, 1, 2, 1, 4]);


        // board 배열의 맨 뒤 배열의 moves[i-1] 값부터 찾아내 없으면 배열-1의 값을 찾아내야 한다.
        // 보드의 맨 뒤 배열부터 차례로 1씩 적어지게 포문 돌린다. moves의 [i]번째 내용의 값
        // 값-1한 것이 맨뒤에부터 존재하는지 찾고(0이 아닌지) 있으면 그놈을 배열0으로 바꿔주고
        // 바구니에 push해준다.
        // 사용자가 입력한 숫자 -1번째 보드 배열에서 (맨뒤배열부터 차례로 찾는다.)
        // 배열 맨 뒤에서 0을 제외한 놈을 뽑아서 backet에 넣고
        // basket에 같은 숫자가 생긴다면 배열에서 삭제해 주고 카운트를 2 증가시킨뒤
        
        // 일단 맨 뒤 보드(board[보드길이-1])에서 moves[0, 나중에점점늘어남]번을 찾아준다.
        // return 1;


  </script>
</html>
